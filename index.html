<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI LotoBot</title>
  <link rel="stylesheet" href="ai-lotobot.css">
  
  <style>
    /* Estilos adicionais apenas para os elementos de autentica√ß√£o */
    .auth-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      gap: 10px;
    }
    .auth-button {
      background-color: rgba(0, 0, 0, 0.7);
      color: var(--neon-blue);
      border: 1px solid var(--neon-blue);
      border-radius: 5px;
      padding: 8px 15px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s;
    }
    .auth-button:hover {
      background-color: var(--neon-blue);
      color: black;
    }
    .admin-button {
      border-color: var(--neon-green);
      color: var(--neon-green);
    }
    .admin-button:hover {
      background-color: var(--neon-green);
    }
    .logout-button {
      border-color: #ff5555;
      color: #ff5555;
    }
    .logout-button:hover {
      background-color: #ff5555;
    }

    /* CSS do Rob√¥ LSTM Lotobot */
    .robot-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      pointer-events: auto;
    }

    .robot {
      width: 120px;
      height: 140px;
      position: relative;
      animation: robotFloat 3s ease-in-out infinite;
      cursor: pointer;
    }

    /* Cabe√ßa do rob√¥ */
    .robot-head {
      width: 60px;
      height: 50px;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 2px solid var(--neon-blue);
      border-radius: 15px;
      position: relative;
      margin: 0 auto;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    /* Olhos do rob√¥ */
    .robot-eye {
      width: 12px;
      height: 12px;
      background: var(--neon-green);
      border-radius: 50%;
      position: absolute;
      top: 15px;
      box-shadow: 0 0 10px var(--neon-green);
      animation: robotBlink 4s infinite;
    }

    .robot-eye.left {
      left: 12px;
    }

    .robot-eye.right {
      right: 12px;
    }

    /* Antena */
    .robot-antenna {
      width: 2px;
      height: 15px;
      background: var(--neon-blue);
      position: absolute;
      top: -15px;
      left: 50%;
      transform: translateX(-50%);
      box-shadow: 0 0 5px var(--neon-blue);
    }

    .robot-antenna::after {
      content: '';
      width: 6px;
      height: 6px;
      background: var(--neon-green);
      border-radius: 50%;
      position: absolute;
      top: -3px;
      left: -2px;
      box-shadow: 0 0 8px var(--neon-green);
      animation: antennaGlow 2s ease-in-out infinite alternate;
    }

    /* Corpo do rob√¥ */
    .robot-body {
      width: 80px;
      height: 60px;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 2px solid var(--neon-blue);
      border-radius: 10px;
      margin: 5px auto;
      position: relative;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
    }

    /* Painel do corpo */
    .robot-panel {
      width: 50px;
      height: 30px;
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid var(--neon-blue);
      border-radius: 5px;
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
    }

    /* LEDs do painel */
    .robot-led {
      width: 4px;
      height: 4px;
      border-radius: 50%;
      position: absolute;
      top: 8px;
    }

    .robot-led:nth-child(1) {
      left: 8px;
      background: var(--neon-green);
      box-shadow: 0 0 5px var(--neon-green);
      animation: ledBlink 1s infinite;
    }

    .robot-led:nth-child(2) {
      left: 18px;
      background: #ff6b6b;
      box-shadow: 0 0 5px #ff6b6b;
      animation: ledBlink 1s infinite 0.3s;
    }

    .robot-led:nth-child(3) {
      left: 28px;
      background: #ffd93d;
      box-shadow: 0 0 5px #ffd93d;
      animation: ledBlink 1s infinite 0.6s;
    }

    .robot-led:nth-child(4) {
      left: 38px;
      background: var(--neon-blue);
      box-shadow: 0 0 5px var(--neon-blue);
      animation: ledBlink 1s infinite 0.9s;
    }

    /* Bra√ßos do rob√¥ */
    .robot-arm {
      width: 15px;
      height: 40px;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 1px solid var(--neon-blue);
      border-radius: 8px;
      position: absolute;
      top: 60px;
      box-shadow: 0 0 8px rgba(0, 255, 255, 0.2);
    }

    .robot-arm.left {
      left: -18px;
      animation: armMove 2s ease-in-out infinite;
    }

    .robot-arm.right {
      right: -18px;
      animation: armMove 2s ease-in-out infinite reverse;
    }

    /* Pernas do rob√¥ */
    .robot-leg {
      width: 12px;
      height: 25px;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 1px solid var(--neon-blue);
      border-radius: 6px;
      position: absolute;
      top: 115px;
      box-shadow: 0 0 8px rgba(0, 255, 255, 0.2);
    }

    .robot-leg.left {
      left: 35px;
      animation: legMove 1.5s ease-in-out infinite;
    }

    .robot-leg.right {
      right: 35px;
      animation: legMove 1.5s ease-in-out infinite 0.75s;
    }

    /* Nome do rob√¥ */
    .robot-name {
      position: absolute;
      top: -40px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: var(--neon-green);
      padding: 5px 10px;
      border-radius: 15px;
      border: 1px solid var(--neon-green);
      font-size: 12px;
      font-weight: bold;
      text-shadow: 0 0 5px var(--neon-green);
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
      white-space: nowrap;
      animation: nameGlow 3s ease-in-out infinite alternate;
    }

    /* Bal√£o de fala */
    .robot-speech {
      position: absolute;
      top: -80px;
      left: -50px;
      background: rgba(0, 0, 0, 0.9);
      color: var(--neon-blue);
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid var(--neon-blue);
      font-size: 11px;
      max-width: 150px;
      text-align: center;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
      opacity: 0;
      animation: speechBubble 8s infinite;
    }

    .robot-speech::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid var(--neon-blue);
    }

    /* Anima√ß√µes */
    @keyframes robotFloat {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
    }

    @keyframes robotBlink {
      0%, 90%, 100% { opacity: 1; }
      95% { opacity: 0.3; }
    }

    @keyframes antennaGlow {
      0% { box-shadow: 0 0 8px var(--neon-green); }
      100% { box-shadow: 0 0 15px var(--neon-green), 0 0 25px var(--neon-green); }
    }

    @keyframes ledBlink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    @keyframes armMove {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(15deg); }
    }

    @keyframes legMove {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-3px); }
    }

    @keyframes nameGlow {
      0% { 
        box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        text-shadow: 0 0 5px var(--neon-green);
      }
      100% { 
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
        text-shadow: 0 0 10px var(--neon-green);
      }
    }

    @keyframes speechBubble {
      0%, 15% { opacity: 0; transform: translateY(10px); }
      20%, 80% { opacity: 1; transform: translateY(0px); }
      85%, 100% { opacity: 0; transform: translateY(-10px); }
    }

    /* Movimento do rob√¥ pela tela */
    @keyframes robotWalk {
      0% { 
        right: -150px; 
        transform: scaleX(1);
      }
      25% { 
        right: 50%;
        transform: scaleX(1);
      }
      50% { 
        right: 50%;
        transform: scaleX(-1);
      }
      75% { 
        right: calc(100% - 150px);
        transform: scaleX(-1);
      }
      100% { 
        right: -150px;
        transform: scaleX(1);
      }
    }

    .robot-walking {
      animation: robotWalk 20s linear infinite, robotFloat 3s ease-in-out infinite;
    }

    /* Responsividade */
    @media (max-width: 768px) {
      .robot-container {
        bottom: 10px;
        right: 10px;
      }
      
      .robot {
        width: 80px;
        height: 100px;
        transform: scale(0.8);
      }
      
      .robot-speech {
        font-size: 9px;
        max-width: 120px;
        left: -40px;
      }
    }
  </style>
</head>

<body>
  <!-- Controles de autentica√ß√£o -->
  <div class="auth-controls">
    <button id="adminBtn" class="auth-button admin-button" style="display: none;">Painel Admin</button>
    <button id="logoutBtn" class="auth-button logout-button">Sair</button>
  </div>

  <div class="circuit-bg"></div>
  <div class="code-lines" id="code-lines"></div>
  <div class="energy-circles" id="energy-circles"></div>

  <h1><span class="ia-badge">IA</span>AI LotoBot</h1>

  <div class="container">
    <div class="update-button-container">
      <div class="update-button-bg"></div>
      <button id="updateButton">Atualizar Resultados</button>
    </div>

    <div class="last-update" id="last-update">√öltima atualiza√ß√£o: Nunca</div>
    <div class="progress-container">
      <div class="progress-bar" id="progress-bar"></div>
    </div>

    <div class="lottery-buttons">
      <button id="megaSenaButton" class="lottery-button pulse-button active" data-lottery="Mega-Sena">Mega-Sena</button>
      <button id="lotofacilButton" class="lottery-button pulse-button" data-lottery="Lotof√°cil">Lotof√°cil</button>
      <button id="lotomaniaButton" class="lottery-button pulse-button" data-lottery="Lotomania">Lotomania</button>
      <input type="hidden" id="lottery" value="Mega-Sena">
    </div>

    <input type="number" id="numGames" value="10" min="1" max="100" placeholder="N√∫mero de jogos">

    <div class="model-toggle">
      <label class="switch">
        <input type="checkbox" id="useAI" checked>
        <span class="slider"></span>
      </label>
      <span>Usar modelo de IA (LSTM)</span>
    </div>

    <div class="button-group">
      <button id="generateButton">Gerar Jogos</button>
      <button id="clearButton" class="clear-button pulse-button">Limpar</button>
      <button id="checkGamesButton">Conferir Jogos</button>
    </div>

    <div class="logs" id="logs"></div>
  </div>

  <!-- Rob√¥ LSTM Lotobot -->
  <div class="robot-container" id="robotContainer">
    <div class="robot" id="lstmRobot">
      <!-- Nome do rob√¥ -->
      <div class="robot-name">LSTM Lotobot</div>
      
      <!-- Bal√£o de fala -->
      <div class="robot-speech" id="robotSpeech">Ol√°! Sou o LSTM Lotobot!</div>
      
      <!-- Cabe√ßa -->
      <div class="robot-head">
        <div class="robot-antenna"></div>
        <div class="robot-eye left"></div>
        <div class="robot-eye right"></div>
      </div>
      
      <!-- Corpo -->
      <div class="robot-body">
        <div class="robot-panel">
          <div class="robot-led"></div>
          <div class="robot-led"></div>
          <div class="robot-led"></div>
          <div class="robot-led"></div>
        </div>
      </div>
      
      <!-- Bra√ßos -->
      <div class="robot-arm left"></div>
      <div class="robot-arm right"></div>
      
      <!-- Pernas -->
      <div class="robot-leg left"></div>
      <div class="robot-leg right"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>

  <script>
    // FUN√á√ÉO PARA VALIDAR TOKEN COM VERIFICA√á√ÉO DE REVOGA√á√ÉO
    function validateTokenWithAdmin() {
      const currentToken = localStorage.getItem('lotobot_token');
      if (!currentToken) return false;
      
      // SE FOR ADMIN, n√£o verificar na lista (admin usa chave fixa)
      const isAdmin = localStorage.getItem('isAdmin');
      if (isAdmin === 'true') {
        return true; // Admin sempre v√°lido
      }
      
      // APENAS para tokens de usu√°rio comum (que come√ßam com TOKEN_)
      if (!currentToken.startsWith('TOKEN_')) {
        return true; // N√£o √© um token gerado pelo sistema, deixar passar
      }
      
      // Verificar se o token de usu√°rio existe na lista de tokens v√°lidos do admin
      const adminTokens = localStorage.getItem('admin_tokens');
      if (!adminTokens) return true; // Se n√£o h√° lista, deixar passar
      
      try {
        const validTokens = JSON.parse(adminTokens);
        
        // Se o token n√£o est√° na lista de tokens v√°lidos, foi revogado
        if (!validTokens[currentToken]) {
          // Token foi revogado, fazer logout
          localStorage.removeItem('lotobot_token');
          localStorage.removeItem('lotobot_token_expiry');
          localStorage.removeItem('lotobot_user_plan');
          
          alert('Seu token foi revogado pelo administrador. Voc√™ ser√° redirecionado para o login.');
          window.location.href = 'login.html';
          return false;
        }
      } catch (error) {
        console.error('Erro ao verificar tokens:', error);
        return true; // Em caso de erro, deixar passar
      }
      
      return true;
    }

    // Verificar autentica√ß√£o ao carregar a p√°gina
    document.addEventListener('DOMContentLoaded', function() {
      // PRIMEIRA VERIFICA√á√ÉO: Token v√°lido e n√£o revogado
      if (!validateTokenWithAdmin()) return;
      
      // Verificar se o usu√°rio est√° autenticado
      const storedToken = localStorage.getItem('lotobot_token');
      const tokenExpiry = localStorage.getItem('lotobot_token_expiry');
      const isAdmin = localStorage.getItem('isAdmin');
      
      // Verificar se o token √© v√°lido
      if (!storedToken || !tokenExpiry || new Date(tokenExpiry) <= new Date()) {
        // Token inv√°lido ou expirado, redirecionar para login
        window.location.href = 'login.html';
        return;
      }
      
      // Mostrar bot√£o de admin se for administrador
      if (isAdmin === 'true') {
        document.getElementById('adminBtn').style.display = 'inline-block';
      }
      
      // Configurar bot√µes de autentica√ß√£o
      document.getElementById('adminBtn').addEventListener('click', function() {
        window.location.href = 'admin.html';
      });
      
      document.getElementById('logoutBtn').addEventListener('click', function() {
        if (confirm('Deseja realmente sair?')) {
          localStorage.removeItem('lotobot_token');
          localStorage.removeItem('lotobot_token_expiry');
          localStorage.removeItem('lotobot_user_plan');
          localStorage.removeItem('isAdmin');
          window.location.href = 'login.html';
        }
      });
      
      // Adicionar mensagem de boas-vindas
      addLog('Bem-vindo ao AI LotoBot! Voc√™ est√° autenticado.');
    });

    const CONFIGS = {
      'Mega-Sena': {numbers: 6, maxNum: 60, minNum: 1, apiId: 'megasena', fileName: 'mega_sena_results.json'},
      'Lotof√°cil': {numbers: 15, maxNum: 25, minNum: 1, apiId: 'lotofacil', fileName: 'lotofacil_results.json'},
      'Lotomania': {numbers: 50, maxNum: 100, minNum: 0, apiId: 'lotomania', fileName: 'lotomania_results.json'},
    };
    

    // URLs da API da Caixa
    const API_BASE_URL = 'https://servicebus2.caixa.gov.br/portaldeloterias/api';
    const NUM_DRAWS = 70;

    let progress = 0;

    const addLog = (message) => {
      const logs = document.getElementById('logs');
      const timestamp = new Date().toLocaleTimeString();
      logs.innerText += `[${timestamp}] ${message}\n`;
      logs.scrollTop = logs.scrollHeight;
    };

    const updateProgress = (value) => {
      progress = Math.min(100, value);
      document.getElementById('progress-bar').style.width = `${progress}%`;
    };

    const setLastUpdate = (date) => {
      document.getElementById('last-update').innerText = `√öltima atualiza√ß√£o: ${new Date(date).toLocaleString()}`;
    };

    // Fun√ß√£o para limpar os logs
    function clearLogs() {
      document.getElementById('logs').innerText = '';
      addLog('Logs limpos.');
    }

    // Fun√ß√£o para selecionar loteria
    function selectLottery(lotteryName) {
      document.getElementById('lottery').value = lotteryName;
      
      // Remover classe active de todos os bot√µes
      document.querySelectorAll('.lottery-button').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Adicionar classe active ao bot√£o correto
      document.querySelector(`[data-lottery="${lotteryName}"]`).classList.add('active');
      
      addLog(`Loteria selecionada: ${lotteryName}`);
    }

    // Fun√ß√£o para formatar data no padr√£o brasileiro
    function formatDate(dateString) {
      try {
        const date = new Date(dateString);
        return date.toLocaleDateString('pt-BR');
      } catch (error) {
        return dateString;
      }
    }

    // Fun√ß√£o para buscar os resultados de uma loteria da API da Caixa
    async function fetchLotteryResults(lottery) {
      try {
        const lotteryConfig = CONFIGS[lottery];
        const apiId = lotteryConfig.apiId;
        
        addLog(`Buscando resultados para ${lottery}...`);
        updateProgress(10);
        
        const response = await fetch(`${API_BASE_URL}/${apiId}`);
        if (!response.ok) throw new Error(`Erro ao buscar dados: ${response.status}`);
        
        const latestData = await response.json();
        const latestConcurso = latestData.numero;
        
        addLog(`√öltimo concurso: ${latestConcurso}. Buscando hist√≥rico...`);
        updateProgress(20);
        
        const results = [];
        const startConcurso = Math.max(1, latestConcurso - NUM_DRAWS + 1);
        
        // Adicionar o √∫ltimo concurso
        results.push(formatLotteryData(apiId, latestData));
        
        // Buscar os concursos anteriores em lotes
        const concursosToFetch = [];
        for (let i = latestConcurso - 1; i >= startConcurso; i--) {
          concursosToFetch.push(i);
        }
        
        const batchSize = 5;
        const totalBatches = Math.ceil(concursosToFetch.length / batchSize);
        
        for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
          const batchStart = batchIndex * batchSize;
          const batchEnd = Math.min(batchStart + batchSize, concursosToFetch.length);
          const currentBatch = concursosToFetch.slice(batchStart, batchEnd);
          
          addLog(`Buscando lote ${batchIndex + 1}/${totalBatches}...`);
          
          const batchPromises = currentBatch.map(concurso =>
            fetch(`${API_BASE_URL}/${apiId}/${concurso}`)
              .then(resp => resp.ok ? resp.json() : null)
              .catch(() => null)
          );
          
          const batchResults = await Promise.all(batchPromises);
          
          batchResults.forEach(data => {
            if (data) results.push(formatLotteryData(apiId, data));
          });
          
          const progress = 20 + (80 * (batchIndex + 1) / totalBatches);
          updateProgress(progress);
          
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        results.sort((a, b) => parseInt(a.Concurso) - parseInt(b.Concurso));
        
        addLog(`Obtidos ${results.length} resultados`);
        updateProgress(100);
        
        return results;
      } catch (error) {
        addLog(`Erro: ${error.message}`);
        throw error;
      }
    }

    // Fun√ß√£o para formatar os dados da API da Caixa
    function formatLotteryData(apiId, apiData) {
      const formattedResult = {
        Concurso: apiData.numero.toString(),
        Data: formatDate(apiData.dataApuracao),
      };
      
      apiData.dezenasSorteadasOrdemSorteio.forEach((dezena, index) => {
        formattedResult[`Bola${index + 1}`] = dezena.toString().padStart(2, '0');
      });
      
      return formattedResult;
    }

    // Fun√ß√£o para salvar os resultados localmente e baixar o arquivo JSON
    function saveResults(fileName, results) {
      try {
        // Salvar no localStorage para uso pelo gerador
        localStorage.setItem(fileName, JSON.stringify(results));
        localStorage.setItem(`${fileName}_lastUpdate`, new Date().toISOString());
        
        // Criar e baixar o arquivo JSON
        const blob = new Blob([JSON.stringify(results, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        
        URL.revokeObjectURL(url);
        
        return true;
      } catch (error) {
        addLog(`Erro ao salvar: ${error.message}`);
        return false;
      }
    }

    // Fun√ß√£o para atualizar resultados
    async function updateAllLotteryResults() {
      addLog('Iniciando atualiza√ß√£o autom√°tica dos resultados...');
      const steps = Object.keys(CONFIGS).length;
      const stepValue = 100 / steps;
      updateProgress(0);
      
      for (const lottery of Object.keys(CONFIGS)) {
        const startTime = Date.now();
        addLog(`Atualizando resultados de ${lottery}...`);
        try {
          // Buscar resultados da API da Caixa
          const results = await fetchLotteryResults(lottery);
          
          // Salvar resultados localmente e baixar arquivo JSON
          const saved = saveResults(CONFIGS[lottery].fileName, results);
          
          if (saved) {
            addLog(`Resultados de ${lottery} salvos com sucesso!`);
            
            // Exibir o √∫ltimo resultado
            if (results.length > 0) {
              const latestResult = results[results.length - 1];
              const numbers = Object.keys(latestResult)
                .filter(key => key.startsWith('Bola'))
                .map(key => latestResult[key])
                .join(', ');
              addLog(`√öltimo resultado de ${lottery}: ${numbers} (Concurso: ${latestResult.Concurso}, Data: ${latestResult.Data})`);
            }
          } else {
            addLog(`Erro ao salvar resultados de ${lottery}`);
          }
        } catch (error) {
          addLog(`Erro ao atualizar ${lottery}: ${error.message}`);
        }
        addLog(`Tempo para atualizar resultados: ${(Date.now() - startTime) / 1000} segundos`);
        updateProgress(progress + stepValue);
      }
      
      const now = new Date().toISOString();
      localStorage.setItem('lastUpdate', now);
      setLastUpdate(now);
      addLog('Atualiza√ß√£o autom√°tica conclu√≠da.');
    }

    // Fun√ß√£o para preparar os dados para o modelo LSTM
    function prepareDataForLSTM(results, lottery) {
      const {numbers, maxNum, minNum = 1} = CONFIGS[lottery];
      
      // Extrair apenas os n√∫meros sorteados de cada concurso
      const sequences = results.map(result => {
        const numbers = [];
        for (let i = 1; i <= CONFIGS[lottery].numbers; i++) {
          let num = parseInt(result[`Bola${i}`]);
          if (!isNaN(num)) {
            // Para Lotomania, garantir que est√° no range 0-99
            if (lottery === 'Lotomania' && num === 100) {
              num = 0;
            }
            numbers.push(num);
          }
        }
        return numbers.sort((a,
        b) => a - b);
      });
      
      // Converter para one-hot encoding
      const oneHotSequences = sequences.map(seq => {
        const oneHot = Array(maxNum).fill(0);
        seq.forEach(num => {
          // Para Lotomania: √≠ndice direto (0-99), para outras: num-1
          const index = lottery === 'Lotomania' ? num : num - 1;
          if (index >= 0 && index < maxNum) {
            oneHot[index] = 1;
          }
        });
        return oneHot;
      });
    
      
      // Criar pares de entrada/sa√≠da para treinamento
      const X = [];
      const y = [];
            
      for (let i = 0; i < oneHotSequences.length - 1; i++) {
        X.push(oneHotSequences[i]);
        y.push(oneHotSequences[i + 1]);
      }
      
      return {X, y, sequences};
    }

    // Fun√ß√£o para criar e treinar o modelo LSTM
    async function trainLSTMModel(X, y, lottery) {
      const {maxNum} = CONFIGS[lottery];
      
      addLog('Criando modelo LSTM...');
      
      // Converter para tensores do TensorFlow.js
      const xsTensor = tf.tensor(X);
      const ysTensor = tf.tensor(y);
      
      // Redimensionar para formato LSTM [amostras, timesteps, features]
      const reshapedX = xsTensor.reshape([X.length, 1, maxNum]);
      
      // Criar modelo sequencial
      const model = tf.sequential();
      
      // Adicionar camada LSTM
      model.add(tf.layers.lstm({
        units: 100,
        returnSequences: false,
        inputShape: [1, maxNum],
        dropout: 0.3,
        recurrentDropout: 0.3
      }));
      
      // Adicionar camada de sa√≠da
      model.add(tf.layers.dense({
        units: maxNum,
        activation: 'sigmoid'
      }));
      
      // Compilar modelo
      model.compile({
        optimizer: tf.train.adam(0.01),
        loss: 'binaryCrossentropy',
        metrics: ['accuracy']
      });
      
      addLog('Treinando modelo LSTM...');
      updateProgress(0);
      
      // Treinar modelo
      await model.fit(reshapedX, ysTensor, {
        epochs: 70,
        batchSize: 8,
        callbacks: {
          onEpochEnd: (epoch, logs) => {
            if (epoch % 10 === 0) {
              addLog(`√âpoca ${epoch + 1}/100 - Perda: ${logs.loss.toFixed(4)}`);
              updateProgress((epoch + 1));
            }
          }
        }
      });
      
      addLog('Treinamento conclu√≠do!');
      updateProgress(100);
      
      return model;
    }

    // Fun√ß√£o para gerar jogos usando o modelo LSTM com an√°lise de frequ√™ncia
    async function generateGamesWithLSTM(model, lottery, numGames) {
      const {numbers, maxNum} = CONFIGS[lottery];
      
      addLog(`Gerando ${numGames} jogos para ${lottery} usando IA e an√°lise de frequ√™ncia...`);
      
      // Carregar resultados anteriores
      const resultsJson = localStorage.getItem(CONFIGS[lottery].fileName);
      if (!resultsJson) {
        addLog('Erro: Nenhum resultado encontrado. Por favor, atualize os resultados primeiro.');
        return [];
      }
      
      const results = JSON.parse(resultsJson);
      
      // Verificar se temos dados suficientes
      if (results.length < 10) {
        addLog('Aviso: Poucos resultados dispon√≠veis. A precis√£o pode ser afetada.');
      }
      
      addLog(`Analisando ${results.length} sorteios anteriores...`);
      
      // Calcular frequ√™ncia de cada n√∫mero
      const frequency = Array(maxNum + 1).fill(0);
      const recentWeight = Array(maxNum + 1).fill(0);
      
      // Dar mais peso aos sorteios mais recentes
      results.forEach((result, idx) => {
        const weight = Math.pow(0.98, results.length - idx - 1); // Peso exponencial decrescente
        
        for (let i = 1; i <= numbers; i++) {
          const num = parseInt(result[`Bola${i}`]);
          if (!isNaN(num)) {
            frequency[num] += 1;
            recentWeight[num] += weight;
          }
        }
      });
      
      // Preparar dados para o modelo LSTM
      const {sequences} = prepareDataForLSTM(results, lottery);
      
      // Criar jogos √∫nicos
      const games = [];
      const uniqueGames = new Set();
      let attempts = 0;
      const maxAttempts = numGames * 5;
      
      while (games.length < numGames && attempts < maxAttempts) {
        attempts++;
        
        // Escolher uma semente aleat√≥ria entre os √∫ltimos 10 resultados
        const seedIndex = Math.floor(Math.random() * Math.min(10, sequences.length));
        const seedResult = sequences[sequences.length - 1 - seedIndex];
        
        // Criar array one-hot da semente
        const seedOneHot = Array(maxNum).fill(0);
        seedResult.forEach(num => {
          const index = lottery === 'Lotomania' ? num : num - 1;
          if (index >= 0 && index < maxNum) {
            seedOneHot[index] = 1;
          }
        });
        
        // Introduzir varia√ß√£o aleat√≥ria na semente
        const numChanges = Math.floor(Math.random() * 6) + 3;
        for (let j = 0; j < numChanges; j++) {
          const pos = Math.floor(Math.random() * maxNum);
          seedOneHot[pos] = seedOneHot[pos] === 0 ? 1 : 0;
        }
        
        // Preparar entrada para o modelo
        const input = tf.tensor(seedOneHot).reshape([1, 1, maxNum]);
        
        // Fazer previs√£o
        const prediction = model.predict(input);
        const probs = await prediction.data();
        
        // Combinar previs√£o do modelo com an√°lise de frequ√™ncia
        const combinedScores = Array(maxNum).fill(0);
        
        for (let i = 0; i < maxNum; i++) {
          // Normalizar frequ√™ncia
          const freqScore = frequency[i + 1] / Math.max(...frequency);
          // Normalizar peso recente
          const recencyScore = recentWeight[i + 1] / Math.max(...recentWeight);
          // Probabilidade do modelo
          const modelScore = probs[i];
          
          // Combinar scores com mais aleatoriedade e menos overfitting
          combinedScores[i] = (modelScore * 0.25) + (freqScore * 0.15) + (recencyScore * 0.15) + (Math.random() * 0.45);

        
        // Converter para array de pares [n√∫mero, score]
        const numberScores = combinedScores.map((score, index) => {
          const number = lottery === 'Lotomania' ? index : index + 1;
          return [number, score];
        });
        
        // Ordenar por score (decrescente)
        numberScores.sort((a, b) => b[1] - a[1]);
        
        // Selecionar os n√∫meros com maior score
        const selectedNumbers = numberScores.slice(0, numbers).map(pair => pair[0]);
        
        // Ordenar n√∫meros em ordem crescente
        selectedNumbers.sort((a, b) => a - b);
        
        // Verificar se este jogo j√° existe
        const gameKey = selectedNumbers.join(',');
        
        if (!uniqueGames.has(gameKey)) {
          uniqueGames.add(gameKey);
          games.push(selectedNumbers);
          
          // Formatar n√∫meros com zero √† esquerda
          const formattedNumbers = selectedNumbers.map(num => num.toString().padStart(2, '0'));
          
          addLog(`Jogo ${games.length}: ${formattedNumbers.join(', ')}`);
          updateProgress((games.length) * 100 / numGames);
        }
        
        // Limpar tensores para evitar vazamento de mem√≥ria
        input.dispose();
        prediction.dispose();
      }
      
      if (games.length < numGames) {
        addLog(`Aviso: Foram gerados apenas ${games.length} jogos √∫nicos ap√≥s ${attempts} tentativas.`);
      }
      
      return games;
    }

    // Fun√ß√£o para gerar jogos aleat√≥rios (m√©todo original)
    function generateRandomGames(lottery, numGames) {
      const {numbers, maxNum, minNum = 1} = CONFIGS[lottery];
      
      addLog(`Gerando ${numGames} jogos aleat√≥rios para ${lottery}...`);
      
      const games = [];
      
      for (let i = 0; i < numGames; i++) {
        let game;
        let isUnique = false;
        
        // Continuar gerando at√© obter um jogo √∫nico
        while (!isUnique) {
          game = new Set();
          
          // Gerar n√∫meros aleat√≥rios para o jogo
          while (game.size < numbers) {
            // Usar um algoritmo diferente para cada jogo para aumentar a aleatoriedade
            const randomFactor = Math.random() + (i * 0.01);
            const num = Math.floor(randomFactor * maxNum) + minNum;
            game.add(num);
          }
          
          // Converter para array e ordenar
          const sortedGame = [...game].sort((a, b) => a - b);
          
          // Verificar se este jogo j√° existe na lista
          isUnique = !games.some(existingGame =>
            JSON.stringify(existingGame) === JSON.stringify(sortedGame)
          );
          
          if (isUnique) {
            games.push(sortedGame);
          }
        }
        
        // Formatar n√∫meros com zero √† esquerda
        const formattedGame = games[i].map(num => num.toString().padStart(2, '0'));
        
        addLog(`Jogo ${i + 1}: ${formattedGame.join(', ')}`);
        updateProgress((i + 1) * 100 / numGames);
      }
      
      return games;
    }

    // Fun√ß√£o para carregar resultados com fallback para API da Caixa
    async function loadResults(lottery) {
      try {
        // Primeiro tenta carregar do localStorage
        const resultsJson = localStorage.getItem(CONFIGS[lottery].fileName);
        if (resultsJson) {
          addLog(`Resultados de ${lottery} carregados do armazenamento local.`);
          return JSON.parse(resultsJson);
        }
        
        // Se n√£o encontrar no localStorage, tenta buscar do backend
        addLog(`Tentando buscar resultados de ${lottery} do backend...`);
        try {
          const response = await axios.get(
            `https://lotobot-backend.onrender.com/results/${lottery}`,
            {timeout: 10000} // Timeout de 10 segundos
          );
          
          if (response.data.success) {
            addLog(`Resultados de ${lottery} obtidos com sucesso do backend.`);
            return response.data.data;
          } else {
            throw new Error("Backend retornou erro");
          }
        } catch (backendError) {
          // Se falhar, tenta usar a API da Caixa diretamente como fallback
          addLog(`Backend n√£o respondeu. Tentando API da Caixa para ${lottery}...`);
          
          try {
            // Buscar resultados diretamente da API da Caixa
            const results = await fetchLotteryResults(lottery);
            addLog(`Resultados de ${lottery} obtidos com sucesso da API da Caixa.`);
            
            // Salvar os resultados no localStorage para uso futuro
            localStorage.setItem(CONFIGS[lottery].fileName, JSON.stringify(results));
            
            return results;
          } catch (caixaError) {
            addLog(`Erro no fallback para API da Caixa: ${caixaError.message}`);
            throw new Error(`N√£o foi poss√≠vel obter resultados para ${lottery}`);
          }
        }
      } catch (error) {
        addLog(`Erro ao carregar resultados de ${lottery}: ${error.message}`);
        return [];
      }
    }

    // Fun√ß√£o para gerar jogos - MODIFICADA para armazenar os jogos gerados
    async function generateGames() {
      const lottery = document.getElementById('lottery').value;
      const numGames = parseInt(document.getElementById('numGames').value);
      const useAI = document.getElementById('useAI').checked;
      
      if (isNaN(numGames) || numGames < 1 || numGames > 100) {
        addLog('Por favor, insira um n√∫mero de jogos v√°lido (1 a 100).');
        return;
      }
      
      try {
        let games = [];
        
        if (useAI) {
          // Usar modelo LSTM para gerar jogos
          addLog(`Iniciando gera√ß√£o de ${numGames} jogos para ${lottery} usando IA...`);
          
          // Carregar resultados anteriores
          const results = await loadResults(lottery);
          if (results.length === 0) {
            addLog('Erro: Nenhum resultado encontrado. Por favor, atualize os resultados primeiro.');
            return;
          }
          
          addLog(`Carregados ${results.length} resultados anteriores.`);
          
          // Preparar dados para o modelo
          const {X, y} = prepareDataForLSTM(results, lottery);
          
          // Treinar modelo LSTM
          const model = await trainLSTMModel(X, y, lottery);
          
          // Gerar jogos usando o modelo treinado
          games = await generateGamesWithLSTM(model, lottery, numGames);
        } else {
          // Usar m√©todo aleat√≥rio original
          games = generateRandomGames(lottery, numGames);
        }
        
        // Armazenar os jogos gerados para confer√™ncia posterior
        window.generatedGames = games;
        
        // Exportar para Excel com formata√ß√£o correta
        const wsData = games.map((game, index) => {
          const row = {Jogo: index + 1};
          game.forEach((num, i) => {
            // Formatar TODOS os n√∫meros com zero √† esquerda
            const formattedNum = num.toString().padStart(2, '0');
            row[`Bola${i + 1}`] = formattedNum;
          });
          return row;
        });
        
        const ws = XLSX.utils.json_to_sheet(wsData);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, lottery);
        XLSX.writeFile(wb, `${lottery}_jogos.xlsx`);
        
        addLog(`Arquivo ${lottery}_jogos.xlsx ge
rado com sucesso!`);
      } catch (error) {
        addLog(`Erro ao gerar jogos: ${error.message}`);
        console.error(error);
      }
    }

    // Fun√ß√£o para conferir jogos gerados contra resultados anteriores
    async function checkGamesAgainstHistory() {
      const lottery = document.getElementById('lottery').value;
      
      // Verificar se h√° jogos gerados
      if (!window.generatedGames || window.generatedGames.length === 0) {
        addLog('Nenhum jogo para conferir. Por favor, gere jogos primeiro.');
        return;
      }
      
      // Carregar resultados hist√≥ricos
      const resultsJson = localStorage.getItem(CONFIGS[lottery].fileName);
      if (!resultsJson) {
        addLog('Erro: Nenhum resultado hist√≥rico encontrado. Por favor, atualize os resultados primeiro.');
        return;
      }
      
      const historicalResults = JSON.parse(resultsJson);
      
      // Preparar dados para passar para a nova p√°gina
      const checkData = {
        lottery: lottery,
        games: window.generatedGames,
        historicalResults: historicalResults,
        config: CONFIGS[lottery]
      };
      
      // Salvar dados no localStorage para a nova p√°gina acessar
      localStorage.setItem('checkData', JSON.stringify(checkData));
      
      // Abrir nova aba
      window.open('check-results.html', '_blank');
    }

    // Carregar a √∫ltima data de atualiza√ß√£o
    const lastUpdate = localStorage.getItem('lastUpdate');
    if (lastUpdate) {
      setLastUpdate(lastUpdate);
    }

    // Event listeners
    document.getElementById('generateButton').addEventListener('click', generateGames);
    document.getElementById('clearButton').addEventListener('click', clearLogs);
    document.getElementById('checkGamesButton').addEventListener('click', checkGamesAgainstHistory);
    document.getElementById('updateButton').addEventListener('click', updateAllLotteryResults);

    // Event listeners para os bot√µes de loteria
    document.querySelectorAll('.lottery-button').forEach(button => {
      button.addEventListener('click', function() {
        const lottery = this.getAttribute('data-lottery');
        selectLottery(lottery);
      });
    });

    // Selecionar Mega-Sena por padr√£o
    selectLottery('Mega-Sena');

    // Fun√ß√£o para animar o rob√¥
    function animateRobot() {
      const robot = document.getElementById('lstmRobot');
      const speech = document.getElementById('robotSpeech');
      const eyes = document.querySelectorAll('.robot-eye');
      const leds = document.querySelectorAll('.robot-led');
      
      // Anima√ß√£o de piscar dos olhos
      setInterval(() => {
        eyes.forEach(eye => {
          eye.style.height = '2px';
          setTimeout(() => {
            eye.style.height = '12px';
          }, 150);
        });
      }, 3000);
      
      // Anima√ß√£o dos LEDs
      let ledIndex = 0;
      setInterval(() => {
        leds.forEach((led, index) => {
          led.style.backgroundColor = index === ledIndex ? '#00ff00' : '#333';
        });
        ledIndex = (ledIndex + 1) % leds.length;
      }, 500);
      
      // Frases do rob√¥
      const phrases = [
        'Analisando padr√µes...',
        'Processando dados hist√≥ricos...',
        'Calculando probabilidades...',
        'IA LSTM ativa!',
        'Gerando previs√µes...',
        'Otimizando algoritmos...',
        'Pronto para gerar jogos!',
        'Sistema neural funcionando!'
      ];
      
      // Trocar frases periodicamente
      setInterval(() => {
        const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
        speech.textContent = randomPhrase;
        
        // Anima√ß√£o de fala
        speech.style.transform = 'scale(1.05)';
        setTimeout(() => {
          speech.style.transform = 'scale(1)';
        }, 200);
      }, 5000);
    }

    // Iniciar anima√ß√µes do rob√¥
    animateRobot();

    // Fun√ß√£o para mostrar/ocultar o rob√¥
    function toggleRobot() {
      const robotContainer = document.getElementById('robotContainer');
      const isVisible = robotContainer.style.display !== 'none';
      
      if (isVisible) {
        robotContainer.style.display = 'none';
        addLog('Rob√¥ LSTM ocultado.');
      } else {
        robotContainer.style.display = 'block';
        addLog('Rob√¥ LSTM ativado!');
      }
    }

    // Adicionar controle do rob√¥ via teclado (tecla R)
    document.addEventListener('keydown', function(event) {
      if (event.key.toLowerCase() === 'r' && event.ctrlKey) {
        event.preventDefault();
        toggleRobot();
      }
    });

    // Fun√ß√£o para verificar se h√° atualiza√ß√µes dispon√≠veis
    async function checkForUpdates() {
      try {
        const lastUpdate = localStorage.getItem('lastUpdate');
        if (!lastUpdate) return;
        
        const lastUpdateDate = new Date(lastUpdate);
        const now = new Date();
        const hoursSinceUpdate = (now - lastUpdateDate) / (1000 * 60 * 60);
        
        // Se passou mais de 24 horas desde a √∫ltima atualiza√ß√£o
        if (hoursSinceUpdate > 24) {
          addLog('‚ö†Ô∏è Dados podem estar desatualizados. Considere atualizar os resultados.');
        }
      } catch (error) {
        console.error('Erro ao verificar atualiza√ß√µes:', error);
      }
    }

    // Verificar atualiza√ß√µes ao carregar a p√°gina
    setTimeout(checkForUpdates, 2000);

    // Fun√ß√£o para salvar configura√ß√µes do usu√°rio
    function saveUserSettings() {
      const settings = {
        defaultLottery: document.getElementById('lottery').value,
        defaultNumGames: document.getElementById('numGames').value,
        defaultUseAI: document.getElementById('useAI').checked
      };
      
      localStorage.setItem('userSettings', JSON.stringify(settings));
    }

    // Fun√ß√£o para carregar configura√ß√µes do usu√°rio
    function loadUserSettings() {
      try {
        const settings = JSON.parse(localStorage.getItem('userSettings'));
        if (settings) {
          if (settings.defaultLottery) {
            selectLottery(settings.defaultLottery);
          }
          if (settings.defaultNumGames) {
            document.getElementById('numGames').value = settings.defaultNumGames;
          }
          if (settings.defaultUseAI !== undefined) {
            document.getElementById('useAI').checked = settings.defaultUseAI;
          }
        }
      } catch (error) {
        console.error('Erro ao carregar configura√ß√µes:', error);
      }
    }

    // Salvar configura√ß√µes quando houver mudan√ßas
    document.getElementById('lottery').addEventListener('change', saveUserSettings);
    document.getElementById('numGames').addEventListener('change', saveUserSettings);
    document.getElementById('useAI').addEventListener('change', saveUserSettings);

    // Carregar configura√ß√µes ao inicializar
    loadUserSettings();

    // Fun√ß√£o para mostrar estat√≠sticas r√°pidas
    function showQuickStats() {
      const lottery = document.getElementById('lottery').value;
      const resultsJson = localStorage.getItem(CONFIGS[lottery].fileName);
      
      if (!resultsJson) {
        addLog('Nenhum dado dispon√≠vel para estat√≠sticas.');
        return;
      }
      
      const results = JSON.parse(resultsJson);
      const {numbers, maxNum} = CONFIGS[lottery];
      
      // Calcular frequ√™ncia dos n√∫meros
      const frequency = Array(maxNum + 1).fill(0);
      
      results.forEach(result => {
        for (let i = 1; i <= numbers; i++) {
          const num = parseInt(result[`Bola${i}`]);
          if (!isNaN(num)) {
            frequency[num]++;
          }
        }
      });
      
      // Encontrar n√∫meros mais e menos sorteados
      let maxFreq = 0, minFreq = Infinity;
      let mostDrawn = [], leastDrawn = [];
      
      for (let i = 1; i <= maxNum; i++) {
        if (frequency[i] > maxFreq) {
          maxFreq = frequency[i];
          mostDrawn = [i];
        } else if (frequency[i] === maxFreq) {
          mostDrawn.push(i);
        }
        
        if (frequency[i] < minFreq) {
          minFreq = frequency[i];
          leastDrawn = [i];
        } else if (frequency[i] === minFreq) {
          leastDrawn.push(i);
        }
      }
      
      addLog(`üìä Estat√≠sticas de ${lottery}:`);
      addLog(`Total de sorteios analisados: ${results.length}`);
      addLog(`N√∫meros mais sorteados (${maxFreq}x): ${mostDrawn.join(', ')}`);
      addLog(`N√∫meros menos sorteados (${minFreq}x): ${leastDrawn.join(', ')}`);
    }

    // Adicionar bot√£o de estat√≠sticas (voc√™ pode adicionar no HTML se quiser)
    // Para agora, usar Ctrl+S para mostrar estat√≠sticas
    document.addEventListener('keydown', function(event) {
      if (event.key.toLowerCase() === 's' && event.ctrlKey) {
        event.preventDefault();
        showQuickStats();
      }
    });

    // Adicionar informa√ß√µes de ajuda
    addLog('üí° Dicas:');
    addLog('‚Ä¢ Ctrl+R: Mostrar/ocultar rob√¥ LSTM');
    addLog('‚Ä¢ Ctrl+S: Mostrar estat√≠sticas r√°pidas');
    addLog('‚Ä¢ Use IA para an√°lise avan√ßada com redes neurais');
    addLog('‚Ä¢ Atualize os resultados regularmente para melhor precis√£o');

  </script>
</body>
</html>
